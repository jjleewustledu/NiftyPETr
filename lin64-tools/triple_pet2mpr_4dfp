#!/bin/csh
# $Header: /home/usr/jon/bin/RCS/triple_pet2mpr_4dfp,v 1.4 2011/09/12 13:17:32 jon Exp jon $
# $Log: triple_pet2mpr_4dfp,v $
# Revision 1.4  2011/09/12 13:17:32  jon
# linux usage adjustment
#
# Revision 1.3  2011/09/01 18:55:51  jon
# useT removed oc sqrt as option
#
# Revision 1.2  2011/08/26 20:24:05  jon
# improved params file interaction, log file names, variable names
#
# Revision 1.1  2011/07/29 16:11:42  jon
# Initial revision
#
# Revision 1.1  2011/03/03  19:34:46  larsc
# Initial revision
#
# Algorithm:
# The purpose of this script is to register an MPRAGE to an atlas target and
# to a triple pack of metabolic PET scans. The target registration for the
# PET scans is then determined and registration quality is quanitfied.

# Five paired alignments are calculated with imgreg_4dfp. The oc to mprage
# and the PET to target registrations are calculated with t4_mul.

# The resolved t4, and sub files, are placed in the resolved_t4 directory 
# with the MPRAGE atlas t4. The other t4 files are 
# placed in the unresolved_t4 directory.

set idstr   = '$Id: triple_pet2mpr_4dfp,v 1.4 2011/09/12 13:17:32 jon Exp jon $'
echo $idstr
set program = $0
set program = $program:t

if (${#argv} < 5) then
	echo "Usage:	$program <patid> <(4dfp)mprage_image> <(4dfp)ho_image> <(4dfp)oo_image> <(4dfp)oc_image>"
	echo " e.g.,	$program p5999 p5999_mprage p5999ho1_sumall p5999oo1_sumall p5999oc1_sumall"
        echo "		Image order must be exact. A patid_triple.params must exist and"
        echo "		will be sourced to change the target and registration parameters"
	exit 1
endif

set imgv = ()
set patid = $argv[1]
set imgv = ($argv[2] $argv[3] $argv[4] $argv[5])

set bin = $RELEASE
set oristr  = (T C S)
set modes   = (4099 4099 3075 2051 10243)

# Default registration parameters for pairwise alignments
set tarv   = (1   1   2   2   3)
set srcv   = (2   3   3   4   4)
set tblurv = (0.9 0.9 8.0 6.0 7.0)
set sblurv = (7.0 6.0 9.0 6.0 7.0)
set kmodev = (1   1   3   3   3)

set targetpath = "/data/cninds01/data2/atlas" 
set target = "TRIO_Y_NDC"		

@ triple_pet2mpr_4dfp_masking = 0	# default 0= do not mask PET
@ triple_pet2mpr_oc_sqrt = 1		# default 1= use sqrt filter

if(-e $patid"_triple.params")then
   source $patid"_triple.params"
else
   echo $program Error $patid"_triple.params" does not exist
   exit 1
endif

@ mask = $triple_pet2mpr_4dfp_masking		# from params file
echo targetpath/target = $targetpath/$target	# from params file

set imgv    = ($imgv:gr)
set imgv    = ($imgv:gr)   ## Images used for t4 file naming
set imgw    = ()           ## Unblurred versions of images used for alignment
set imgm    = ()           ## Created masks
set imgr    = ()           ## Images to be removed

# Check for images
@ i = 1
while ($i <= 4)
   if (! -e $imgv[$i].4dfp.ifh || ! -e $imgv[$i].4dfp.img) then
	echo "${program}: $imgv[$i] not found"
	exit -1
   else
        echo $imgv[$i].4dfp.img Exists
   endif
   @ i++
end
# Create mpr to target if it does not exist
# params file supplies $targetpath/$target

echo Using targetpath $targetpath for target $target
if(! -e $targetpath/$target".4dfp.img")then
	   echo $targetpath/$target".4dfp.img" Does Not Exist
           exit 1
endif

set mpratlt4 = ${imgv[1]}_to_${target}_t4

if (! -e $mpratlt4) then
		echo $mpratlt4 not found
		echo "mpr2atl_4dfp $imgv[1] -T$targetpath/$target"
		      mpr2atl_4dfp $imgv[1] -T$targetpath/$target
		if ($status) exit $status
else
        	echo Atlas t4 file $mpratlt4 Exists
endif

# Mask the mpr if $mask is set
if ($mask) then
	if (! -e $imgv[1]_mskt.4dfp.img) then
		echo "msktgen_4dfp $imgv[1] -T$targetpath/$target"
		      msktgen_4dfp $imgv[1] -T$targetpath/$target
		if ($status) exit $status
	endif
	set imgm = ($imgv[1]_mskt)
else
	set imgm = ("none")
endif

# Preprocess PET. Make msk if $mask is set and add to $imgm.
set imgw = ($imgw $imgv[1])
foreach img ($imgv[2-])
	if (! -e $img.4dfp.ifh || ! -e $img.4dfp.img) then
		echo "${program}: $img not found"
		exit -1
	endif
	if ($mask) then
		if (! -e ${img}_msk.4dfp.ifh || ! -e ${img}_msk.4dfp.img) then
			imgblur_4dfp $img 5
			maskimg_4dfp ${img}_b50 ${img}_b50 -p5 ${img}_temp$$
			set lims = `gawk '/matrix size \[3\]/ {m = int(0.09*$NF); print (m+1)"to"($5-m)}' $img.4dfp.ifh`
			crop_4dfp -Z -z$lims ${img}_temp$$ ${img}_msk
			if ($status) exit $status
			rm ${img}_b50.4dfp.{img,ifh,hdr,img.rec}
			rm ${img}_temp$$.4dfp.{img,ifh,hdr,img.rec}
			set imgr = ($imgr ${img}_msk)
		endif
		set imgm = ($imgm ${img}_msk)
	else
		set imgm = ($imgm "none")
	endif
	# 
	if ($img == $imgv[4] && triple_pet2mpr_oc_sqrt == 1) then
		sqrt_4dfp $img
		set imgr = ($imgr ${img}_sqrt)
		set imgw = ($imgw ${img}_sqrt)
	else
		set imgw = ($imgw ${img})
	endif
end

set imgreglog = $patid"_"$program.log
if (-e $imgreglog) /bin/rm $imgreglog
date >! $imgreglog
echo imgreg_4dfp OUTPUT will be placed in $imgreglog

@ i = 1
while ($i <= $#tarv)
	if ($tarv[$i] == 1) then
		set text = `echo $tblurv[$i] | gawk '{print "g"10*$1}'`
		if (! -e $imgw[$tarv[$i]]_$text.4dfp.img) then
			gauss_4dfp $imgw[$tarv[$i]] $tblurv[$i]
			set imgr = ($imgr $imgw[$tarv[$i]]_$text)
		endif
	else
		set text = `echo $tblurv[$i] | gawk '{print "b"10*$1}'`
		if (! -e $imgw[$tarv[$i]]_$text.4dfp.img) then
			imgblur_4dfp $imgw[$tarv[$i]] $tblurv[$i]
			set imgr = ($imgr $imgw[$tarv[$i]]_$text)
		endif
	endif
	if ($srcv[$i] == 1) then
		set sext = `echo $sblurv[$i] | gawk '{print "g"10*$1}'`
		if (! -e $imgw[$srcv[$i]]_$sext.4dfp.img) then
			gauss_4dfp $imgw[$srcv[$i]] $sblurv[$i]
			set imgr = ($imgr $imgw[$srcv[$i]]_$sext)
		endif
	else
		set sext = `echo $sblurv[$i] | gawk '{print "b"10*$1}'`
		if (! -e $imgw[$srcv[$i]]_$sext.4dfp.img) then
			imgblur_4dfp $imgw[$srcv[$i]] $sblurv[$i]
			set imgr = ($imgr $imgw[$srcv[$i]]_$sext)
		endif
	endif

	set ori = `gawk '/orientation/ {print $NF-1}' $imgw[$tarv[$i]].4dfp.ifh $imgw[$srcv[$i]].4dfp.ifh`
	t4_inv $bin/$oristr[$ori[1]]_t4 temp$$_t4
	t4_mul $bin/$oristr[$ori[2]]_t4 temp$$_t4 $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4
	t4_inv $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4
	       rm temp$$_t4

	@ k = $kmodev[$i]
	while ($k < $#kmodev)
	   echo imgreg_4dfp $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4 $modes[$k]
	   $bin/imgreg_4dfp $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4 $modes[$k]
		if ($status) exit $status
	   echo imgreg_4dfp $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgv[$tarv[$i]]_to_$imgv[$srcv[$i]]_t4 $modes[$k]
           $bin/imgreg_4dfp $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgv[$tarv[$i]]_to_$imgv[$srcv[$i]]_t4 $modes[$k]
		if ($status) exit $status
		@ k ++
	end
	echo imgreg_4dfp $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4 $modes[$k]
	echo imgreg_4dfp $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4 $modes[$k] >> $imgreglog
	$bin/imgreg_4dfp $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgv[$srcv[$i]]_to_$imgv[$tarv[$i]]_t4 $modes[$k] >> $imgreglog
	if ($status) exit $status
	echo imgreg_4dfp $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgv[$tarv[$i]]_to_$imgv[$srcv[$i]]_t4 $modes[$k]
	echo imgreg_4dfp $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgv[$tarv[$i]]_to_$imgv[$srcv[$i]]_t4 $modes[$k] >> $imgreglog
	$bin/imgreg_4dfp $imgw[$srcv[$i]]_$sext $imgm[$srcv[$i]] $imgw[$tarv[$i]]_$text $imgm[$tarv[$i]] $imgv[$tarv[$i]]_to_$imgv[$srcv[$i]]_t4 $modes[$k] >> $imgreglog
	if ($status) exit $status
	@ i ++
end

##################################################################################################
# Quality check of image pairs registrations using t4_resolve

set resolvelog = $patid"_"$program"_t4_resolve.log"
if (-e $resolvelog) /bin/rm $resolvelog
date >! $resolvelog
echo t4_resolve OUTPUT will be placed in $resolvelog

echo t4_resolve $imgv[1] $imgv[2] -ohompr >> $resolvelog
     t4_resolve $imgv[1] $imgv[2] -ohompr >> $resolvelog
if ($status) exit $status
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog`
echo "hompr ERROR = " $error >> $resolvelog
echo                                      >> $resolvelog
echo t4_resolve $imgv[2] $imgv[3] -oooho  >> $resolvelog
     t4_resolve $imgv[2] $imgv[3] -oooho  >> $resolvelog
if ($status) exit $status
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog`
echo "ooho ERROR = " $error >> $resolvelog
echo                                      >> $resolvelog
echo t4_resolve $imgv[3] $imgv[4] -oocoo  >> $resolvelog
     t4_resolve $imgv[3] $imgv[4] -oocoo  >> $resolvelog
if ($status) exit $status
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog`
echo "ocoo ERROR = " $error >> $resolvelog
echo                                      >> $resolvelog
echo t4_resolve $imgv[2] $imgv[4] -oocho  >> $resolvelog
     t4_resolve $imgv[2] $imgv[4] -oocho  >> $resolvelog
if ($status) exit $status
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog`
echo "ocho ERROR = " $error >> $resolvelog
echo                                      >> $resolvelog
echo t4_resolve $imgv[1] $imgv[3] -ooompr >> $resolvelog
     t4_resolve $imgv[1] $imgv[3] -ooompr >> $resolvelog
if ($status) exit $status
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog`
echo "oompr ERROR = " $error >> $resolvelog

##################################################################################################
# Quality control check of the data using t4_resolve on the mr, ho, and oo t4 files
echo                                                 >> $resolvelog
echo t4_resolve $imgv[1] $imgv[2] $imgv[3] -ohooompr >> $resolvelog
     t4_resolve $imgv[1] $imgv[2] $imgv[3] -ohooompr >> $resolvelog
if ($status) exit $status

# Determine quality of the t4_resolve ho oo mpr script, then print output
set error = `gawk '/rotation/{rot = $5} /translation/{trans = $5} END {printf("%3d",100*(trans+1.4*rot))}' $resolvelog` 
echo                           >> $resolvelog
echo "hooompr ERROR = " $error
echo "hooompr ERROR = " $error >> $resolvelog

if ($error < 100) then
    echo "error is LOW, image reconciliation is good"             >> $resolvelog
else if (($error > 100) && ($error < 200)) then
    echo "error is MED, cross-image reconciliation is acceptable" >> $resolvelog
else if ($error > 200) then
    echo "error is HIGH, cross-image reconciliation is poor"      >> $resolvelog
endif

##################################################################################################
# Reorganize t4 files

set unres = unresolved_t4
if (! -e $unres) mkdir $unres

foreach img1 ($imgv)
foreach img2 ($imgv)
	if (-e ${img1}_to_${img2}_t4) mv -f ${img1}_to_${img2}_t4 $unres
end
end

cp -f $imgv[2]"_to_hompr_t4" $imgv[2]"_to_"$imgv[1]"_t4"
cp -f $imgv[3]"_to_ooho_t4"  $imgv[3]"_to_"$imgv[2]"_t4"
cp -f $imgv[4]"_to_ocoo_t4"  $imgv[4]"_to_"$imgv[3]"_t4"
cp -f $imgv[4]"_to_ocho_t4"  $imgv[4]"_to_"$imgv[2]"_t4"
cp -f $imgv[3]"_to_oompr_t4" $imgv[3]"_to_"$imgv[1]"_t4"

t4_mul $imgv[4]"_to_"$imgv[2]"_t4" $imgv[2]"_to_"$imgv[1]"_t4"
foreach img ($imgv[2-])
	t4_mul $img"_to_"$imgv[1]"_t4" $imgv[1]"_to_"$target"_t4"
end

set res = resolved_t4
if (! -e $res) mkdir $res

mv -f *hompr* *ooho* *ocoo* *ocho* *oompr* $res

@ i = 2
while ($i < 5)
        mv -f $imgv[$i]"_to_"$target"_t4" $res 
        @ i++
end

##################################################################################################
# Clean up

foreach img ($imgr)
	rm -f ${img}.4dfp.{img,ifh,hdr,img.rec}
end

echo Done $program
exit 0

